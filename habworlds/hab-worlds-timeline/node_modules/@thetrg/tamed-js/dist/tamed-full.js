!function(r){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.uuidv4=r()}}(function(){return function r(e,n,t){function o(f,u){if(!n[f]){if(!e[f]){var a="function"==typeof require&&require;if(!u&&a)return a(f,!0);if(i)return i(f,!0);var d=new Error("Cannot find module '"+f+"'");throw d.code="MODULE_NOT_FOUND",d}var p=n[f]={exports:{}};e[f][0].call(p.exports,function(r){var n=e[f][1][r];return o(n?n:r)},p,p.exports,r,e,n,t)}return n[f].exports}for(var i="function"==typeof require&&require,f=0;f<t.length;f++)o(t[f]);return o}({1:[function(r,e,n){function t(r,e){var n=e||0,t=o;return t[r[n++]]+t[r[n++]]+t[r[n++]]+t[r[n++]]+"-"+t[r[n++]]+t[r[n++]]+"-"+t[r[n++]]+t[r[n++]]+"-"+t[r[n++]]+t[r[n++]]+"-"+t[r[n++]]+t[r[n++]]+t[r[n++]]+t[r[n++]]+t[r[n++]]+t[r[n++]]}for(var o=[],i=0;i<256;++i)o[i]=(i+256).toString(16).substr(1);e.exports=t},{}],2:[function(r,e,n){var t="undefined"!=typeof crypto&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&msCrypto.getRandomValues.bind(msCrypto);if(t){var o=new Uint8Array(16);e.exports=function(){return t(o),o}}else{var i=new Array(16);e.exports=function(){for(var r,e=0;e<16;e++)0===(3&e)&&(r=4294967296*Math.random()),i[e]=r>>>((3&e)<<3)&255;return i}}},{}],3:[function(r,e,n){function t(r,e,n){var t=e&&n||0;"string"==typeof r&&(e="binary"===r?new Array(16):null,r=null),r=r||{};var f=r.random||(r.rng||o)();if(f[6]=15&f[6]|64,f[8]=63&f[8]|128,e)for(var u=0;u<16;++u)e[t+u]=f[u];return e||i(f)}var o=r("./lib/rng"),i=r("./lib/bytesToUuid");e.exports=t},{"./lib/bytesToUuid":1,"./lib/rng":2}]},{},[3])(3)});
'use strict';

// Check if we are in a NodeJs environment.
if (typeof window == 'undefined') {
    var jsdom = require('jsdom');
    var window = new jsdom.JSDOM ('').window;
    global.window = window;
    global.document = window.document;
    global.window.isNodeJs = true;
}

// Poly fill

// Object.assign
// ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of function is 2
            'use strict';
            if (target == null) { // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }
            
            var to = Object(target);
            
            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];
                
                if (nextSource != null) { // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}

// Boot up the Tamed object.
(function () {
    // Attach the Tamed object to the window.
    if (!window.tm) {
        var o, cache, config, db, isReady, preload, simple;

        // Create the Tamed object.
        isReady = false;
        config = {
            start: {},
        };
        cache = {
            loaded: {},
            object: {}
        };
        db = {};

        preload = {
            object: [],
            load: [],
        };

        o = {
            _info: {
                type: '/tamed-js/Tamed.js',
                version: '1.0.0',
                coreObject: true,
            },
            _data: {},
            _method: {
                _shared: {
                    bootup: function (internal) {
                        isReady = true;
                        var dom, html, tmConfig;

                        // Clear out setup items.
                        delete o._method._shared.bootup;
                        delete o._method._shared.getPreloader;

                        var key, list;
                        list = window._tmConfig;
                        for (key in list) {
                            window._tmConfig [key] = null;
                            delete window._tmConfig [key];
                        }

                        // Attach the shared methods to the object.
                        buildStructure ({o: o, data: {target: o._data, isData: true}});
                        buildStructure ({o: o, data: {target: o._method}});
                        setupQuickReference ({o: o, data: {target: o}});

                        // Ensure we have a Tamed area.
                        dom = document.querySelector ('#tamed-area');
                        if (!dom) {
                            dom = document.createElement ('div');
                            dom.id = 'tamed-area';
                            document.body.appendChild (dom);

                            html = [
                                '<div id="tamed-js-area" style="display: none">',
                                    '<div id="script-area" style="display: none">',
                                        '<div id="script-dynamic">',
                                        '</div>',
                                        '<div id="script-static">',
                                        '</div>',
                                    '</div>',
                                '</div>',
                                '',
                            ].join ('');

                            dom.innerHTML = html;
                        }

                        // Load the preloaded loaders to load.
                        simple.bootup (internal);

                        // Add the preloaded objects for the object cache.
                        preload.object.forEach (function (item) {
                            cache.object [item.name] = item.object;
                        })

                        // Clear out the preload list.
                        preload.object = null;
                        preload.load = null;

                        // Run any methods for readyness.
                        if (config && config.start && config.start.list) {
                            var delay;

                            delay = config.start.delay;
                            if (!delay) { delay = 0; }

                            setTimeout (function () {
                                config.start.list.forEach (function (item) {
                                    // Run each start method.
                                    item.apply (o, []);
                                });
                                config.start.list = null;
                            }, delay);
                        }

                        return o;
                    },
                    copy: function () {
                    },
                    buildStructure: buildStructure,
                    define: function () {
                    },
                    emulateKey: function (data) {
                        // ref: http://keycode.info/
                        // console.log ('- firing tab...');
                        var evnt;

                        if (!data) { data = {}; }
                        if (!data.key) { data.key = 'tab'; }
                        // console.log ('key:', data.key);

                        if (data.key == 'tab') {
                            data.char = '\t';
                            data.keyCode = 9;
                        }
                        else {
                            data.char = data.key;
                            if (!data.keyCode) {
                                data.keyCode = data.key.toUpperCase ().charCodeAt (0);
                            }
                        }

                        // data.char = 'a';
                        // data.key = 'a';
                        // data.keyCode = 65;
                        if (!data.shiftKey) { data.shiftKey = false; }
                        data.bubbles = true;
                        data.cancelable = true;

                        function chromeHack (keyEvnt) {
                            // ref: https://stackoverflow.com/a/23812767
                            // ref: https://stackoverflow.com/a/10520017
                            // Chrome Hack
                            Object.defineProperty(keyEvnt, 'keyCode', {
                                        get : function() {
                                            return data.keyCode;
                                        }
                            });
                            Object.defineProperty(keyEvnt, 'which', {
                                        get : function() {
                                            return data.keyCode;
                                        }
                            });
                            return keyEvnt;
                        }

                        var evnt = chromeHack (new KeyboardEvent ('keydown', data));
                        document.body.dispatchEvent (evnt);

                        var evnt = chromeHack (new KeyboardEvent ('keyup', data));
                        document.body.dispatchEvent (evnt);
                    },
                    generateTmId: function (base) {
                        var id;
                        // var data, id, timestamp, type;

                        // // Set object context.
                        // // o = data.o;
                        // data = data.data;
                        //
                        // // Code body.
                        // timestamp = data.timestamp;
                        // if (!timestamp) { timestamp = moment (); }
                        //
                        // type = data.type;
                        // id = '' +
                        //     type + ':' +
                        //     timestamp.format ('YYYY-MM-DD-HH-mm-ss-SSS') + ':' +
                        //     _tm.randomString ({o: _tm, data: {length: 8}});
                        //
                        // // NOTE: In the future add a way to ensure unique
                        // // ids by maybe tracking the timestamp or last
                        // // couple id's in the last 2 seconds generated?
                        if (!base) {
                            base = '';
                        }
                        else {
                            base = base + '-';
                        }

                        id = base + Date.now () + '-' + tm.randomString ();
                        return id;
                    },
                    getData: function (key) {
                        return db [key];
                    },
                    getInfo: function (useSimple) {
                        return {
                            version: o._info.version,
                        }
                    },
                    getPreloader: function (useSimple) {
                        if (useSimple) {
                            return simple.getPreloader ();
                        }
                        return preload;
                    },
                    getStartList: function () {
                        o._method._shared.getStartList = undefined;
                        delete o._method._shared.getStartList;

                        return config.start;
                    },
                    isReady: function () {
                        return isReady;
                    },
                    merge: merge,
                    randomString: function (data) {
                        // ref: https://stackoverflow.com/a/1349426
                        var end, i, possible, text;

                        // Set object context.
                        // o = data.o;
                        if (!data) { data = {}; }
                        if (!data.length) { data.length = 20; }

                        data = data;

                        text = '';
                        possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

                        end = data.length;
                        for (var i = 0; i < end; i++) {
                            text += possible.charAt (Math.floor (Math.random () * possible.length));
                        }

                        return text;
                    },
                    setData: function (key, value) {
                        db [key] = value;
                    },
                    setupQuickReference: setupQuickReference,
                    setSimpleTamed: function (simpleObj) {
                        window.tm.setSimpleTamed = null;
                        delete window.tm.setSimpleTamed;

                        // Build out the simple tamed object.
                        simple = simpleObj ();
                        merge ({o: o, data: {
                            source: simple,
                            target: o._method._shared,
                            keepOriginal: true,
                        }});
                    },
                    start: function (callback) {
                        // var o;

                        if (isReady) {
                            // Run each start method.
                            callback.apply (o, []);
                        }
                        else {
                            if (!config) { config = {}; }
                            // o = config;
                            // if (!config.start) { config.start = {}; }
                            if (!config.start.list) { config.start.list = []; }

                            config.start.list.push (callback);
                        }
                    },
                }
            },
        };

        o._method._shared.run = o._method._shared.start;

        // Methods that need to pre-exist in
        // order to create Tamed.
        var buildStructure = function (data) {
            var cursor;

            // Set the bag defaults.
            if (!data.o) {data.o = window._tm;}
            if (!data.data) {data.data = {};}

            // Set object context.
            // o = data.o;
            data = data.data;
            cursor = data.target;

            if (data.isData) {
                if (!cursor._constant) { cursor._constant = {}; }
            }
            else {
                if (!cursor._event) { cursor._event = {}; }
            }

            if (!cursor._unique) { cursor._unique = {}; }
            if (!cursor._private) { cursor._private = {}; }
            if (!cursor._shared) { cursor._shared = {}; }
            if (!cursor._dynamic) { cursor._dynamic = {}; }
        }

        var kill = function () {
            var item, key, list, o;

            o = this;
            list = o;
            for (key in list) {
                o [key] = null;
                delete o [key];
            }
        }

        var merge = function (data) {
            var item, keepOriginal, key, list, o, source, target;

            // Set object context.
            // o = data.o;
            data = data.data;

            source = data.source;
            target = data.target;
            keepOriginal = data.keepOriginal;

            if (source && target) {
                list = source;
                for (key in list) {
                    if (typeof list [key] === 'object') {
                        // Duplicate the keys of nested objects.
                        if (!target [key]) { target [key] = {}; }

                        if (keepOriginal === true) {
                            if (target [key] === undefined) {
                                merge ({o: o, data: {source: list [key], target: target [key]}});
                            }
                        }
                        else {
                            merge ({o: o, data: {source: list [key], target: target [key]}});
                        }
                    }
                    else {
                        // Duplicate the references or values.
                        if (keepOriginal === true) {
                            if (target [key] === undefined) {
                                target [key] = list [key];
                            }
                        }
                        else {
                            target [key] = list [key];
                        }
                    }
                }
            }

            return target;
        }

        var setup = function () {
            var tmConfig;

            // Set the start callback methods to run once
            // Tamed has booted up.
            tmConfig = Object.assign ({}, window._tmConfig);
            if (tmConfig && tmConfig.test && tmConfig.test.start) {
                tmConfig.test.start ();
            }
            else {
                // console.log ('- Booting up Tamed...');
                o._method._shared.bootup ();
            }
        }

        var setupQuickReference = function (data) {
            var target;

            // Set the bag defaults.
            if (!data.o) {data.o = window._tm;}
            if (!data.data) {data.data = {};}

            // Create a context for quick lookup.
            // o = data.o;
            data = data.data;
            target = data.target;

            target._dc   = target._data._constant;
            target._du   = target._data._unique;
            target._dp   = target._data._private;
            target._ds   = target._data._shared;

            target._me   = target._method._event;
            target._mu   = target._method._unique;
            target._mp   = target._method._private;
            target._ms   = target._method._shared;
        }

        // Create the Tamed object.
        if (window.isNodeJs) {
            window.tm = o._method._shared;
            global.tm = window.tm;
            // isReady = true;
            tm.boot = function () {
                tm.boot = null;
                delete tm.boot;
                setup ();
                return tm;
            }
            // setTimeout (function () { setup (); }, 1)
        }
        else {
            window.tm = o._method._shared;
            
            // When iframed and iframed, there is a potential the 
            // 'onload' event will not fire if content is not loaded 
            // by normal means.
            // ref: https://stackoverflow.com/a/20624274/3268255
            if (window.self !== window.top) {
                var timer = setInterval (function () {
                    if (window.document.body &&  
                        window.document.body.children &&
                        window.document.body.children.length > 0) {
                            
                        console.log ('- Tamed booting up:', Date.now ());
                        setup ();
                        clearInterval (timer);
                        
                        return;
                    }
                }, 100);
            }
            else {
                window.addEventListener ('load', setup);
            }
        }

        // Check if Cypress test environment is running.
        if (window.Cypress) {
            window.Cypress.tm = window.tm;
        }
    }
}) ()

'use strict';

// Boot up the Tamed object.
tm.setSimpleTamed (function () {
    var o, dataArea, cache, config, preload;

    // Create the Tamed object.
    config = {};
    cache = {
        object: [],
        loaded: [],
    };
    preload = {
        name: 'simple',
        object: [],
        load: [],
    }

    dataArea = {};

    // Attach the Tamed object to the window.
    o = {
        add: function (name, extendList, object) {
            // console.log ('cache:', cache.object);
            if (!Array.isArray (extendList)) {
                object = extendList;
                // extendList = null;
            }

            if (!tm.isReady ()) {
                preload.object.push ({name: name, extendList: extendList, object: object});
                return window.tm;
            }

            if (!cache.object [name]) {
                if (extendList && extendList !== object) {
                    object._extendList = extendList;
                }

                // console.log ('type:', (typeof object));
                cache.object [name] = object;
                return window.tm;
            }

            // Error could not find object.
            throw new Error ('Object "' + name + '" already defined.');
            return window.tm;
        },
        addHtml: function (name, template) {
            if (config.templater) {
                return config.templater.addHtml (name, template)
            }
        },
        bootup: function (internal) {
            var loader;

            // // Create the loader.
            // if (config.loader) {
            //     config.loader (preload)
            //     loader = 'trg.loader.simple.Loader';
            // }

            // Add references for testing.
            if (internal) {
                internal.cache = cache;
            }

            // Load the preloaded loaders to load.
            if (preload.load [0]) {
                o.load (preload.load [0]);
            }

            // Add the preloaded objects for the object cache.
            preload.object.forEach (function (item) {
                o.add (item.name, item.extendList, item.object);
            })

            // // If a loader is specified, use it.
            // if (loader) {
            //     loader = tm.new (loader);
            // }

            // Clear out the preload list.
            preload.object = null;
            preload.load = null;

            o.bootup = null;
            delete o.bootup;
        },
        emptyFunc: function () {},
        getContent: function (data) {
            if (config.loader) {
                return config.loader.getContent (data);
            }
        },
        getData: function (name) {
            return dataArea [name];
        },
        getFuncParams: function (func) {
            if (tm.getType (func) == 'Function') {
                func = func.toString ();
                func = func.substring (func.indexOf ('(') + 1);
                func = func.substring (0, func.indexOf (')'));
                func = func.split (',');
                return func;
            }
            return [];
        },
        getHtmlTemplater: function () {
            return config.templater;
        },
        getLineInfo: function (noFrame, offset) {
            var end, line, start;
            line = getLogLine (offset);

            start = '[';
            end = ']'
            if (noFrame) {
                start = '';
                end = '';
            }

            return start + line.file + ':' + line.number + ':' + line.column + end;
        },
        getPreloader: function (useSimple) {
            return preload;
        },
        getType: function (item) {
            var index1, index2, type;
            
            type = 'UnKnown';
            if (item === undefined) {
                type = 'Undefined';
            }
            else if (item.getInfo) {
                type = item.getInfo ('type');
            }
            else if (item === null) {
                type = 'Null';
            }
            else if (item === Infinity) {
                type = 'Infinity';
            }
            else if (item === Math) {
                type = 'Math';
            }
            else {
                type = item.constructor.toString ();
                index1 = type.indexOf (' ');
                index2 = type.indexOf ('(');
                type = type.substring (index1, index2).trim ();
            }

            if (type === 'Number') {
                if (isNaN (item)) {
                    type = 'NaN'
                }
                else if (item.toString ().indexOf ('.') > -1) {
                    type = 'Decimal';
                }
                else {
                    type = 'Integer';
                }
            }

            return type;
        },
        html: function (name, template) {
            if (config.templater) {
                return config.templater.html (name, template)
            }
        },
        isLoaded: function (name) {
            if (cache.object [name]) {
                return true;
            }
            return false;
        },
        js: function (name, data) {
            var item;
            if (data === undefined) { data = name }

            if (tm.getType (data) == 'Function') {
                data = data ();
            }

            if (tm.getType (name) == 'String') {
                tm.setData (name, data);
            }
            return data;
        },
        load: function (data) {
            var count, end, errorList, extension, i, item, list, nonJsList, loaded, url;
            // var end, extension, i, item;

            if (!tm.isReady ()) {
                if (!preload.load.length) {
                    var origDone;

                    // Convert the done method into an array of callbacks.
                    if (!data.done) { data.done = []; }
                    if (!Array.isArray (data.done)) {
                        origDone = data.done;
                        data.done = [
                            origDone,
                        ]
                    }

                    // Set this loader as the first loader item.
                    preload.load.push (data);
                    return window.tm;
                }

                // Push the load data into the pre-existing load data.
                var loadDoneList, loadList;

                loadDoneList = preload.load [0].done;
                loadList = preload.load [0].list;

                loadList.push.apply (loadList, data.list);
                if (data.done) {
                    loadDoneList.push (data.done);
                }

                // Pull out any item that is not a javascript file.
                return window.tm;
            }

            function checkIfDone () {
                var info, error;

                if (count >= list.length) {
                    var error;

                    if (errorList.length) { error = errorList; }
                    if (data.done) {
                        info = {
                            count: count,
                            list: list,
                            loaded: loaded,
                            nonJsList: nonJsList,
                            errorList: errorList,
                            force: data.force,
                        }

                        if (config.loader) {
                            info.done = data.done;
                            config.loader.load (info);
                        }
                        else {
                            if (Array.isArray (data.done)) {
                                data.done.forEach (function (item) {
                                    item (info);
                                })
                            }
                            else {
                                data.done (info);
                            }
                        }
                    }
                }
            }

            function fileDone (file) {
                var info;
                // Increment the count and make check if all
                // the dependent files have been loaded.
                loaded [file] = true;
                cache.loaded [file] = true;

                count++;
                checkIfDone ();
            }

            function loadScript (file) {
                var dom, parent;

                // Attach the script file to the page.
                if (!window.isNodeJs) {
                    parent = document.querySelector ('#tamed-area #script-area #script-dynamic');
                    dom = document.createElement ('script');
                    dom.src = file;

                    dom.onload = function (evnt) {
                        fileDone (file);
                    }

                    dom.onerror = function (evnt) {
                        errorList.push (Error ('Unable to load file: ' + file));
                        fileDone (file);
                    }

                    try {
                        parent.appendChild (dom);
                    }
                    catch (err) {
                        errorList.push (Error ('Unable to load file: ' + file + '\n' + err.message));
                    }

                    // Track the files that are being loaded.
                    loaded [file] = false;
                    cache.loaded [file] = false;
                }
                else {
                    // var dir = process.cwd () + '/node_modules/express-tamed';
                    // Load the tamed file through NodeJs.

                    // Track the files that are being loaded.
                    loaded [file] = false;
                    cache.loaded [file] = false;

                    try {
                        console.log ('- loading:', file);
                        // console.log ('*** here', process.cwd () + file + 'fds');
                        // console.log ('*** here', process.cwd () + file); process.exit ();
                        require (file);
                        fileDone (file);

                        loaded [file] = true;
                        cache.loaded [file] = true;
                    }
                    catch (err) {
                        var msg = 'Unable to load file: ' + file + '\n' + err.message;
                        errorList.push (Error (msg));
                        console.log ('\x1b[1m\x1b[38;5;15m\x1b[48;5;9m ' + 'ERROR:\x1b[0m ' + msg + '')
                        fileDone (file);
                    }
                }
            }

            errorList = [];
            loaded = {};
            count = 0;
            list = data.list;
            nonJsList = [];

            if (!list) { list = []; }

            if (!Array.isArray (list)) {
                list = [list];
            }

            end = list.length;
            for (i = 0; i < end; i++) {
                item = list [i];

                url = item;
                if (tm.getType (item) === 'Object') { url = item.url }

                extension = url.substring (url.lastIndexOf ('.') + 1)
                if (extension !== 'js') {
                    nonJsList.push (item);
                    count++;
                }
                else {
                    // Make sure we aren't already loading the item.
                    if (loaded [item] === undefined && !cache.loaded [item]) {
                        loadScript (item);
                    }
                    else {
                        count++;
                    }
                }
            }

            // If nothing is loaded call the done callback.
            if (Object.keys (loaded).length == 0 && data.done) {
                checkIfDone ();
            }
        },
        merge: function (data) {
            var item, keepOriginal, key, list, obj, source, target;

            // Set object context.
            // o = data.o;
            if (!data.o) {
                data = data;
            }
            else {
                obj = data.o;
                data = data.data;
            }

            source = data.source;
            target = data.target;
            keepOriginal = data.keepOriginal;

            if (source && target) {
                list = source;
                for (key in list) {
                    if (typeof list [key] === 'object') {
                        // Duplicate the keys of nested objects.
                        if (!target [key]) { target [key] = {}; }

                        if (keepOriginal === true) {
                            if (target [key] === undefined) {
                                // merge ({o: o, data: {source: list [key], target: target [key]}});
                                o.merge ({source: list [key], target: target [key]});
                            }
                        }
                        else {
                            // merge ({o: o, data: {source: list [key], target: target [key]}});
                            o.merge ({source: list [key], target: target [key]});
                        }
                    }
                    else {
                        // Duplicate the references or values.
                        if (keepOriginal === true) {
                            if (target [key] === undefined) {
                                target [key] = list [key];
                            }
                        }
                        else {
                            target [key] = list [key];
                        }
                    }
                }
            }

            return target;
        },
        new: function (name, config) {
            var base, built, o, obj, result;
            // console.log ('cache:', cache.object);

            if (cache.object [name]) {
                if (!config) { config = {}; }
                base = cache.object [name];

                // if (base._built) {
                if (base._built === true) {
                    built = base._built;
                    base._buildCount++;

                    obj = Object.assign ({}, built);
                    obj.info = {
                        type: built.info.type,
                        id: tm.generateTmId () + '-' + uuidv4 () + '-' + base._buildCount,
                        // id: tm.generateTmId () + '-' + base._buildCount,
                        createCount: base._buildCount,
                        extendList: built.info.extendList,
                        usingCachedBuild: true,
                    };

                    // Allow metadata about object.
                    obj.o.getInfo = wrapGetInfo (obj);

                    // Remove the data.
                    obj.d = {
                        _config: config
                    };

                    // var end, i, item, key, list;
                    // list = obj.setupList;
                    // end = list.length;
                    //
                    // for (i = 0; i < end; i++) {
                    //     item = list [i];
                    //     item.apply (obj.o, [obj.d, config]);
                    // }
                }
                else {
                    // Build the new object's construction
                    // context object.
                    if (!base._buildCount) { base._buildCount = 0; }
                    base._buildCount++;

                    obj = {
                        info: {
                            type: name,
                            id: tm.generateTmId () + '-' + uuidv4 (),
                            // id: tm.generateTmId () + '-' + 1,
                            createCount: base._buildCount,
                            extendList: [],
                            usingCachedBuild: false,
                        },
                        
                        // Externally shared public methods.
                        o: {
                        },
                        
                        // Internally shared private methods.
                        p: {},
                        
                        // Internally event area methods.
                        e: {
                        },

                        setupList: [
                        ],

                        override: {
                            o: {},
                            p: {},
                            e: {},
                        },

                        // // Externally shared public methods.
                        // o: {
                        //     // override: createOverrideMethod (obj, 'o'),
                        //     // override: function (overrideObj) {
                        //     //     var item, key, list, target;
                        //     // 
                        //     //     list = overrideObj;
                        //     //     target = obj.override.o;
                        //     //     for (key in list) {
                        //     //         target [key] = list [key];
                        //     //     }
                        //     // },
                        // },
                        // 
                        // // Internally shared private methods.
                        // p: {
                        //     // _override: {},
                        //     // override: override: createOverrideMethod ('p'),
                        //     // override: function (overrideObj) {
                        //     //     var item, key, list, target;
                        //     // 
                        //     //     list = overrideObj;
                        //     //     target = obj.override.p;
                        //     //     for (key in list) {
                        //     //         target [key] = list [key];
                        //     //     }
                        //     // },
                        // },
                    }
                    
                    if (config._info && !config.uniqueId) { 
                        obj.info.id = config._info.id; 
                    }

                    // Remove the data.
                    obj.o.override = createOverrideMethod (obj, 'o');
                    obj.p.override = createOverrideMethod (obj, 'p');
                    obj.e.override = createOverrideMethod (obj, 'e');
                    obj.d = {
                        _config: config,
                        _info: {
                            id: obj.info.id,
                            type: obj.info.type,
                        }
                    };
                    
                    obj.o._setupStackList = [];
                    obj.e._setupStackList = [];

                    // Allow metadata about object.
                    obj.o.getInfo = wrapGetInfo (obj);
                    obj.o.extendsFrom = wrapExtendsFrom (obj);

                    // Grab the extension list and begin
                    // extending the object.
                    extend (name, obj, base._extendList);

                    // Run the final object constructor.
                    runConstructor (base, name, obj, name);

                    // // Wrap each override method.
                    // wrapOverrideMethod (name, 'shared', obj.override.o, obj.o);
                    // wrapOverrideMethod (name, 'private', obj.override.p, obj.p);
                    // wrapOverrideMethod (name, 'event', obj.override.e, obj.e);

                    // // Cached to construction context for faster
                    // // generation of instances in the future.
                    // base._built = Object.assign ({}, obj);
                    // base._built.d = {};

                    // Remove the override areas.
                    delete obj.o.override;
                    delete obj.p.override;
                    
                    if (obj.e) {
                        delete obj.e.override;
                    }
                }

                obj.o.toString = wrapToString (obj);
                obj.o._kill = wrapKill (obj);

                // Run the setup.
                var end, i, item, key, list;
                list = obj.setupList;
                end = list.length;

                for (i = 0; i < end; i++) {
                    item = list [i];
                    item.apply (obj.o, [config]);
                }
                
                // If using chirp, fire the prepare event.
                if (obj.e && obj.e.setup) {
                    obj.e.setup (config);
                    delete obj.e.setup;
                }
                
                // Go through the setup stack list.
                list = obj.o._setupStackList;
                end = list.length;
                for (i = 0; i < end; i++) {
                    item = list [i];
                    item = obj.o [item];
                    if (item) {
                        item.apply (obj.o, [config]);
                        obj.o [item] = null;
                        delete obj.o [item];
                    }
                }
                obj.o._setupStackList = null;
                delete obj.o._setupStackList;
                
                // // Go through the setup stack list for commands
                // list = obj.e._setupStackList;
                // end = list.length;
                // for (i = 0; i < end; i++) {
                //     item = list [i];
                //     item = obj.e [item];
                //     if (item) {
                //         item.apply (obj.e, [config]);
                // 
                //     }
                // }
                // obj.o._setupStackList = null;
                // delete obj.o._setupStackList;
                
                if (obj.e && obj.e._setup) {
                    obj.e._setup (config);
                    delete obj.e._setup;
                }

                return obj.o;
            }
            else {
                throw new Error ('The simple Tamed "' + name + '" object does not exist. It has not been loaded.');
            }
        },
        resolvePath: function (path) {
            if (!path) { path = ''; }
            path = path.trim ();
            
            if (path [0] == '/') {
                path = '@public/' + path;
            }
            
            if (path.indexOf ('@public/') == 0) {
                path = path.replace ('@public/', '/public/');
            }
            return path;
        },
        sendTestResult: function (runner) {
            var data, end, i, item, key, list, parent, queryString;
            
            parent = window.parent;
            if (window !== parent) {
                
                // Pull the target parent from the url.
                // console.log ('*** what:', document.URL);
                // console.log ('query string:', queryString);
                // url = document.URL; //window.location.href;
                
                queryString = document.URL.split ('?') [1];
                // console.log ('query string:', document.URL);
                // console.log ('query string:', queryString);      
                
                if (queryString) {
                    list = queryString.split ('&');
                    end = list.length;
                    queryString = {};
                    
                    for (i = 0; i < end; i++) {
                        item = list [i];
                        item = item.split ('=');
                        queryString [item [0]] = decodeURIComponent (item [1]);
                    }
                    
                    // console.log ('*** query string:', + list);
                    // console.log ('*** query string:', + queryString);
                    
                    if (queryString.parentHost) {
                        // Get the runner data.
                        // data = {name: 'bob', age: 32};
                        // console.log ('runner:', runner);
                        // data = {
                        //     failures: runner.failures,
                        // };
                        
                        // Send the message to the parent window.
                        parent.postMessage (runner.stats, queryString.parentHost);
                    }
                }
            }
        },
        setContent: function (data) {
            if (config.loader) {
                config.loader.setContent (data);
            }
            return data;
        },
        setData: function (name, data) {
            dataArea [name] = data;
        },
        setHtmlTemplater: function (htmlTemplater) {
            config.templater = htmlTemplater;

            // Remove the ability to set a loader.
            tm.setHtmlTemplater= null;
            delete tm.setHtmlTemplater;
        },
        setLoader: function (loader) {
            config.loader = loader;

            // Remove the ability to set a loader.
            tm.setLoader = null;
            delete tm.setLoader;
        },
        setPlugin: function (name, func) {
            tm [name] = func;
        },
        store: {},
    }
    
    var createOverrideMethod = function (obj, area) {
        return function (overrideObj) {
            var item, key, list, target;

            list = overrideObj;
            target = obj.override [area];
            for (key in list) {
                target [key] = list [key];
            }
        }
    }

    var wrapExtendsFrom = function (obj) {
        return function (toCompare) {
            var extend, type;

            extend = obj.o.getInfo ('extends').split (', ');
            type = (typeof toCompare);

            if (type === 'object') {
                if (toCompare.getInfo) {
                    toCompare = toCompare.getInfo ('type');
                }
            }

            type = (typeof toCompare);
            if (type === 'string') {
                if (extend.indexOf (toCompare) > -1) {
                    return true;
                }
            }

            return false;
        }
    }

    var wrapToString = function (obj) {
        return function () {
            return obj.info.type + '-' + obj.info.id;
        }
    }

    var wrapGetInfo = function (obj) {
        var info = obj.info;

        return function (key) {
            var value;

            if (key == 'extends') {
                value = info ['extendList'];
                value = value.join (', ');
            }
            else {
                value = info [key];
            }

            return value;
        }
    }

    var wrapMethod = function (context, original, override) {
        return function () {
            var args;

            args = Array.prototype.slice.call (arguments);
            args = [original].concat (args);
            return override.apply (context, args);
        }
    }

    var wrapOverrideMethod = function (name, area, source, target) {
        var item, key, list;

        list = source;
        for (key in list) {
            if (target [key]) {
                target [key] = wrapMethod (target, target [key], list [key]);
            }
            else {
                throw new Error ('Unable to override "' + key + '" method in the ' + area + ' area because it does not exist in the <' + name + '> object\'s ' + area + ' area.');
            }
        }
    }

    var runConstructor = function (base, name, obj, extendName) {
        var eClone, oClone, pClone, result;

        // Add to the extend list.
        obj.info.extendList.push (extendName);

        // Snapshot current state object.
        pClone = Object.assign ({}, obj.p);
        oClone = Object.assign ({}, obj.o);
        eClone = Object.assign ({}, obj.e);

        // Run the constructor.
        base (obj.o, obj.p, obj.d, obj.e, obj.o);

        // Throw error if object does not have a publicly
        // shared setup method.
        if (!obj.o.setup) { obj.o.setup = tm.emptyFunc; }

        if (obj.o.setup) {
            // obj.o.setup (obj.d._config);
            obj.setupList.push (obj.o.setup);
            delete obj.o.setup;
        }
        else {
            if (extendName !== name) {
                throw new Error ('Unable to extend <' + name + '> from the <' + extendName + '> object. The <' + extendName + '> object does not have a publicly shared "setup" method.');
            }
            else {
                throw new Error ('The <' + name + '> object does not have a publicly shared "setup" method.');
            }
        }

        // Confirm the object's original methods
        // have NOT been modified.
        ensureOriginalMethod (name, pClone, obj.p, 'private');
        ensureOriginalMethod (name, oClone, obj.o, 'shared');
        ensureOriginalMethod (name, eClone, obj.e, 'event');
        
        // Wrap each override method.
        wrapOverrideMethod (name, 'shared', obj.override.o, obj.o);
        wrapOverrideMethod (name, 'private', obj.override.p, obj.p);
        wrapOverrideMethod (name, 'event', obj.override.e, obj.e);
    }

    var ensureOriginalMethod = function (name, source, target, area) {
        var item, key, list;

        list = source;
        for (key in list) {
            if (source [key] !== target [key]) {
                throw new Error ('Incorrectly overriding the <' + name + '> object\'s pre-existing "' + key + '" method. To override this method use the ' + area + ' area\'s override () method.');
            }
        }
    }

    var extend = function (name, obj, extendList) {
        var base, clone, extendName;

        if (extendList) {
            extendList.forEach (function (extendName) {
                base = cache.object [extendName];
                if (base) {
                    // Grab the extension list and begin
                    // extending the object.
                    extend (name, obj, base._extendList);

                    // Run the extending object constructor.
                    runConstructor (base, name, obj, extendName);
                    
                    // TODO: Remove this code...?
                    if (obj.d.useChirp && !obj.e.override) {
                        obj.e.override = createOverrideMethod (obj, 'e');
                    }
                }
                else {
                    throw new Error ('Unable to extend <' + name + '>. The inheritance parent <' + extendName + '> does not exist.')
                }
            })
        }
    }

    var deReference = function (list) {
        // Clear out the references.
        var item, key;
        for (key in list) {
            list [key] = null;
            delete list [key];
        }
    }

    var wrapKill = function (obj) {
        return function () {
            // Create a seperate process to kill object.
            setTimeout (function () {
                // Clear out the references for data and methods.
                deReference (obj.d);
                deReference (obj.p);
                deReference (obj.o);
                deReference (obj.e);
            }, 10);
        }
    }

    var setup = function () {
        var tmConfig;

        // Load the preloaded loaders to load.
        if (preload.load [0]) {
            o.load (preload.load [0]);
        }

        // Add the preloaded objects for the object cache.
        preload.object.forEach (function (item) {
            cache.object [item.name] = item.object;
        })

        return o;
    }

    function getLogLine (offset) {
        var index, list, line;

        if (!offset) { offset = 0; }
        if (window.isNodeJs) {
            index = 4 + offset;
        }
        else {
            if (window.navigator.userAgent.indexOf ('Firefox') !== -1){
                index = 3 + offset; // FF
            } else {
                index = 4 + offset; // Chrome
            }
        }

        line = {
            file: 'n/a',
            number: -1,
        }
        try {
            throw new Error ('Getting line number.');
        }
        catch (err) {
            list = err.stack.split ('\n') [index];

            // if (offset == -1) {
                // console.log (err.stack.split ('\n'))
            // }

            if (list) {
                list = list.substring (list.lastIndexOf ('/') + 1, list.length - 1);
                list = list.split (':');
                line.file = list [0];
                line.number = list [1];
                line.column = list [2];
            }

            return line;
        }
    }

    function addLogging () {

        // Add logging
        function warn (msg) {
            var line, info;

            // line = tm.getLogLine ();
            // info = '[' + line.file + ':' + line.number + ':' + line.column + ']';
            info = tm.getLineInfo ();
            if (window.isNodeJs) {
                console.warn ('\x1b[1m\x1b[38;5;0m\x1b[48;5;178m' + ' Warning:' + '\x1b[0m ' + msg [0] + '  \x1b[38;5;22m\x1b[48;5;233m ' + info + ' \x1b[0m')
            }
            else {
                console.warn ('%c' + msg [0] + '%c' + info, '', 'margin-left: 25px; padding: 0 15px 0 15px;');
            }
        }

        function error (msg, err) {
            var line, info;

            // line = tm.getLogLine ();
            // info = '[' + line.file + ':' + line.number + ':' + line.column + ']';
            info = tm.getLineInfo ();
            if (window.isNodeJs) {
                console.error ('\x1b[1m\x1b[38;5;15m\x1b[48;5;1m' + ' ERROR:' + '\x1b[0m ' + msg + '  \x1b[38;5;22m\x1b[48;5;233m ' + info + ' \x1b[0m')
            }
            else {
                console.error ('%c' + msg + '%c' + info, '', 'margin-left: 25px; padding: 0 15px 0 15px;');
            }

            return err;
        }

        // function log () {
        function log (msg, config) {
            var argList, end, i, info, item, line, list, msg;

            argList = [].slice.call(arguments);
            list = argList;
            end = list.length;

            msg = '';
            info = '';
            for (i = 0; i < end; i++) {
                item = list [i];
                msg += item [0] + ' ';
            }
            msg = msg.trim ();

            // Log to the console.
            info = tm.getLineInfo ();
            // info = '[' + line.file + ':' + line.number + ':' + line.column + ']';
            if (window.isNodeJs) {
                if (msg.length) {
                    console.log (msg + '  \x1b[38;5;22m\x1b[48;5;0m ' + info + ' \x1b[0m');
                }
                else {
                    console.log ('');
                }
            }
            else {
                console.log ('%c' + msg + '%c' + info, '', 'background: #fff; color: #fff; margin-left: 25px; padding: 0 15px 0 15px;');
            }
        }

        if (window.isNodeJs) {
            global.log = log;
            global.error = error;
            global.warn = warn;
        }
        else {
            window.log = log;
            window.error = error;
            window.warn = warn;

            window.global = window;
            console.log ('%c' + 'NOTE: ' + '%c' + 'Output from any "log ()" function call should be drag selected with mouse to get the details of the log call.', 'background: #494949; color: #fff; padding: 3px 10px 3px 10px; border-radius: 3px;', 'margin-left: 10px; padding: 0 0 0 0;')
        }
    }

    setup ();
    addLogging ();
    return o;
});
