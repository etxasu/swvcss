'use strict';

describe ('Tamed', function() {
    var loader, internal;
    internal = {};

    describe ('Boot Up', function () {
        it ('should boot up when window is ready.', function () {
            var info, o;

            expect (tm).to.exist;

            // Get info.
            info = tm.getInfo ();
            expect (info).to.exist;
            loader = tm.getPreloader (true);

            window._testData = {
                bootup: {},
                override: {},
            };

            // Log out the tamed object.
            console.log (tm);
        })
        it ('should buffer all loading of objects until Tamed is ready.', function () {
            var loadDoneList, loadList, testData;

            testData = window._testData.bootup;
            tm.load ({
                list: [
                    '/src/test/simple/sample/preload/Object1.js',
                ],
                done: function (data) {
                    window._testData.loadDoneCallback1 = true;
                }
            });

            tm.load ({
                list: [
                    '/src/test/simple/sample/preload/Object2.js',
                ],
            });

            tm.load ({
                list: [
                    '/src/test/simple/sample/preload/Object3.js',
                    '/src/test/simple/sample/preload/Object4.js',
                ],
                done: function (data) {
                    window._testData.loadDoneCallback2 = true;
                }
            });

            loadDoneList = loader.load [0].done;
            loadList = loader.load [0].list;

            expect (loadList).to.have.lengthOf (4);
            expect (loadList [0]).to.equal ('/src/test/simple/sample/preload/Object1.js');
            expect (loadList [1]).to.equal ('/src/test/simple/sample/preload/Object2.js');
            expect (loadList [2]).to.equal ('/src/test/simple/sample/preload/Object3.js');
            expect (loadList [3]).to.equal ('/src/test/simple/sample/preload/Object4.js');

            expect (loadDoneList).to.have.lengthOf (2);
            // expect (1).to.equal (2);
        })
        it ('should buffer all adding of objects until Tamed is ready.', function () {
            tm.add ('test.PreObject1', function (o) {
                window._testData.bootup.PreObject1 = true;
            });
            tm.add ('test.PreObject2', function (o) {
                window._testData.bootup.PreObject2 = true;
            });

            expect (loader.object).to.have.lengthOf (2);
            expect (loader.object [0].name).to.equal ('test.PreObject1');
            expect (loader.object [1].name).to.equal ('test.PreObject2');
        })
        it ('should allow defining of start up callback functions.', function () {
            var start;
            tm.start (function () {
                window._testData.bootup.startFunctionCalled = true;
            })

            start = tm.getStartList ();
            expect (tm.getStartList).to.equal (undefined);
            expect (start).to.exist;
            expect (start.list).to.have.lengthOf (1);
        })
        it ('should allow manual bootup for testing.', function (done) {
            var testData;

            testData = window._testData.bootup;
            expect (tm.isReady ()).to.equal (false);
            expect (window._tmConfig).to.exist;

            expect (testData.PreObject1).to.equal (undefined);
            expect (testData.PreObject2).to.equal (undefined);

            // Make sure the objects have not been defined yet.
            try {
                tm.new ('test.PreObject1');
            }
            catch (err) {
                expect (err.message).to.equal ('The simple Tamed "test.PreObject1" object does not exist. It has not been loaded.');
            }

            // Add to the loader a method to check done load.
            loader.load [0].done.push (function () {
                expect (tm.isReady ()).to.equal (true);
                expect (tm.bootup).to.equal (undefined);
                expect (tm.getPreloader).to.equal (undefined);
                expect (Object.keys (window._tmConfig)).to.have.lengthOf (0);
                expect (window._testData.bootup.startFunctionCalled).to.equal (true);
                done ();
            })

            // Manually startup Tamed.
            console.log ('pre-loader:', loader);
            tm.bootup (internal);
        })
        it ('should auto load buffered objects once Tamed is ready.', function () {
            var testData;
            testData = window._testData.bootup;

            expect (testData.Object1).to.equal (true);
            expect (testData.Object2).to.equal (true);
            expect (testData.Object3).to.equal (true);
            expect (testData.Object4).to.equal (true);

            expect (loader.load).to.equal (null);
        })
        it ('should auto add buffered objects once Tamed is ready.', function () {
            var o, testData;

            testData = window._testData.bootup;
            o = tm.new ('test.PreObject1');
            expect (o).to.exist;
            expect (testData.PreObject1).to.equal (true);

            o = tm.new ('test.PreObject2');
            expect (o).to.exist;
            expect (testData.PreObject2).to.equal (true);

            expect (loader.object).to.equal (null);
        })
        it ('should ensure a dynmaic script area exist.', function () {
            var dom;

            dom = document.querySelector ('#tamed-area #script-area #script-dynamic');
            expect (dom).to.exist;
        })
    })

    describe ('Load Objects', function () {
        var cache, src;

        src = '/src/test/simple/sample/Object1.js';

        it ('should load any Javascript file.', function (done) {
            var dom;

            tm.load ({
                list: [
                    '/src/test/simple/sample/NormalJsFile.js',
                ],
                done: function (data) {

                    expect (data.list).to.have.lengthOf (1);
                    expect (Object.keys (data.loaded)).to.have.lengthOf (1);
                    expect (data.count).to.equal (data.list.length);
                    expect (data.loaded ['/src/test/simple/sample/NormalJsFile.js']).to.equal (true);
                    expect (window._normalJs).to.equal ('A normal js file was loaded.');
                    done ();
                }
            });
        })
        it ('should load a single object.', function (done) {
            var dom;

            tm.load ({
                list: [
                    src,
                ],
                done: function (data) {

                    expect (data.list).to.have.lengthOf (1);
                    expect (Object.keys (data.loaded)).to.have.lengthOf (1);
                    expect (data.count).to.equal (data.list.length);
                    expect (data.loaded [src]).to.equal (true);
                    done ();
                }
            });
        })
        it ('should not load already loaded files.', function (done) {
            tm.load ({
                list: [
                    src,
                    src,
                ],
                done: function (data) {
                    expect (data.list).to.have.lengthOf (2);
                    expect (Object.keys (data.loaded)).to.have.lengthOf (0);
                    expect (data.count).to.equal (2);
                    done ();
                }
            });
        })
        it ('should allow a list of files to be loaded.', function (done) {
            tm.load ({
                list: [
                    src,
                    '/src/test/simple/sample/Object2.js',
                    '/src/test/simple/sample/Object3.js',
                ],
                done: function (data) {
                    expect (data.list).to.have.lengthOf (3);
                    expect (Object.keys (data.loaded)).to.have.lengthOf (2);
                    expect (data.count).to.equal (3);
                    done ();
                }
            });
        })
        it ('should filter out non Javascript files.', function (done) {
            tm.load ({
                list: [
                    '/src/test/simple/sample/Object5.js',
                    '/src/Avatar.png',
                    '/src/Sound.mp3',
                ],
                done: function (data) {
                    // console.log ('*** LOADED:', data);
                    expect (data.list).to.have.lengthOf (3);
                    expect (Object.keys (data.loaded)).to.have.lengthOf (1);
                    expect (data.nonJsList).to.have.lengthOf (2);
                    expect (data.nonJsList [0]).to.equal ('/src/Avatar.png');
                    expect (data.count).to.equal (3);
                    done ();
                }
            });
        })
        it ('should throw an error if any loaded file is not found.', function (done) {
            tm.load ({
                list: [
                    src,
                    '/src/test/simple/sample/Object4.js',
                    '/src/test/simple/sample/ErrorFile.js',
                ],
                done: function (data) {
                    expect (data.errorList).to.exist;
                    expect (data.errorList).to.have.lengthOf (1);
                    expect (data.errorList [0].message).to.equal ('Unable to load file: /src/test/simple/sample/ErrorFile.js');
                    done ();
                }
            })
        })
        it ('should allow getting metadata about instanced objects.', function () {
            var id, obj1, objCache;

            id = 'test.simple.MetaInfo';
            tm.add (id, function (o, p, d) {
            });

            obj1 = tm.new (id);
            expect (obj1.getInfo ('id')).to.exist;
            expect (obj1.getInfo ('type')).to.equal (id);
            expect (obj1.getInfo ('createCount')).to.equal (1);
            expect (obj1.getInfo ('extends')).to.equal (id);
            expect (obj1.getInfo ('usingCachedBuild')).to.equal (false);
            expect ('new id: ' + obj1).to.equal ('new id: ' + obj1.getInfo ('type') + '-' + obj1.getInfo ('id'));
            console.log ('obj: ' + obj1);
        });
        it ('should allow determining what an object extends from.', function () {

            tm.add ('game.GameObject', function (o) {
            });
            tm.add ('game.Player', ['game.GameObject'], function (o) {
            });
            tm.add ('game.player.Mario', ['game.Player'], function (o) {
            });
            tm.add ('game.player.Luigi', ['game.player.Mario'], function (o) {
            });
            tm.add ('game.enemy.Goomba', ['game.GameObject'], function (o) {
            });

            var mario = tm.new ('game.player.Mario');
            var luigi = tm.new ('game.player.Luigi');
            var goomba = tm.new ('game.enemy.Goomba');

            console.log ('extends info:', luigi.getInfo ('extends'));

            expect (luigi.extendsFrom ('game.Player')).to.equal (true);
            expect (luigi.extendsFrom ('game.player.Mario')).to.equal (true);
            expect (luigi.extendsFrom ('game.player.Link')).to.equal (false);
            expect (luigi.extendsFrom (mario)).to.equal (true);
            expect (luigi.extendsFrom ({})).to.equal (false);
            expect (luigi.extendsFrom ([])).to.equal (false);
        });
        it ('should throw error if added object does not have a shared setup method.', function () {
            var o;

            tm.add ('test.simple.NoSharedMethod', function () {
            });

            try {
                o = tm.new ('test.simple.NoSharedMethod');
            }
            catch (err) {
                expect (err.message).to.equal ('The <test.simple.NoSharedMethod> object does not have a publicly shared "setup" method.');
            }
        });
        // it ('should allow the first instance of an object to be used as a construction cache.', function () {
        //     var id, obj1, obj2, objCache;
        //
        //     id = 'test.simple.CacheBuildObject';
        //     tm.add (id, function (o, p, d) {
        //         o.setup = function (config) {
        //             d.name = config.name;
        //             d.age = config.age;
        //         }
        //
        //         o.getName = function () {
        //             return d.name;
        //         }
        //
        //         o.getAge = function () {
        //             return d.age;
        //         }
        //     });
        //
        //     expect (internal.cache.object [id]._built).to.not.exist;
        //     obj1 = tm.new (id, {name: 'jay', age: 21});
        //     expect (obj1.getName ()).to.equal ('jay');
        //     expect (obj1.getAge ()).to.equal (21);
        //     expect (obj1.getInfo ('type')).to.equal (id);
        //     expect (obj1.getInfo ('extends')).to.equal (id);
        //     expect (obj1.getInfo ('createCount')).to.equal (1);
        //     expect (obj1.getInfo ('usingCachedBuild')).to.equal (false);
        //
        //     objCache = internal.cache.object [id]
        //     expect (objCache._built).to.exist;
        //     expect (objCache._buildCount).to.equal (1);
        //
        //     obj2 = tm.new (id, {name: 'jill', age: 45});
        //     expect (obj2.getName ()).to.equal ('jill');
        //     expect (obj2.getAge ()).to.equal (45);
        //     expect (obj2.getInfo ('type')).to.equal (id);
        //     expect (obj2.getInfo ('extends')).to.equal (id);
        //     expect (obj2.getInfo ('createCount')).to.equal (2);
        //     expect (obj2.getInfo ('usingCachedBuild')).to.equal (false);
        //     // expect (obj2.getInfo ('usingCachedBuild')).to.equal (true);
        //     expect (objCache._buildCount).to.equal (2);
        // });
        // it ('should remove data of a construction cached object.', function () {
        //     var id, objCache;
        //
        //     id = 'test.simple.CacheBuildObject';
        //     objCache = internal.cache.object [id];
        //
        //     expect (Object.keys (objCache._built.d)).to.have.lengthOf (0);
        // });
        // it ('should allow creation of an instance to force rebuilding instead of using construction cached object.');


        // NOTE: This is the problem with RBSTW game where the setup methods
        // where being run right after running the base () constructor. This
        // is a problem and should be that all constructors are run and then
        // the object's setup methods are run.
        it ('should make sure to build out the object and then run the setup methods.');

        it ('should throw error if trying to redefine object.', function () {
            try {
                tm.add ('test.simple.Object1');
            }
            catch (err) {
                expect (err.message).to.equal ('Object "test.simple.Object1" already defined.');
            }
        })
        it ('should return the Tamed object when adding an object.', function () {
            var o;
            o = tm.add ('test.simple.Object1b', function () {});
            expect (o).to.equal (window.tm);
        })
    })

    describe ('Manage Objects', function () {
        it ('should create an instance of a cached object.', function () {
            var o;

            o = tm.new ('test.simple.Object1', {name: 'bob', age: 32});
            // console.log ('new object: ', o);

            expect (Object.keys (o)).to.have.lengthOf (6);
            expect (o._kill).to.be.a ('function');
            expect (o.getName).to.be.a ('function');
            expect (o.getAge).to.be.a ('function');

            expect (o.getName ()).to.equal ('bob');
            expect (o.getAge ()).to.equal (32);
        });
        it ('should destroy an instance of a cached object.', function (done) {
            var o;

            o = tm.new ('test.simple.Object1', {name: 'bob', age: 32});
            o._kill ();
            
            setTimeout (function () {
                expect (Object.keys (o)).to.have.lengthOf (0);
                done ();
            }, 15);
        });
    })

    describe ('Extend Objects', function () {
        it ('should allow an object to extend from another.', function (done) {
            var o;

            tm.load ({
                list: [
                    '/src/test/simple/sample/ExtendFromObject.js',
                ],
                done: function () {
                    o = tm.new ('test.simple.ExtendFromObject', {name: 'sally', age: 24});
                    expect (o.getName).to.exist;
                    expect (o.getName ()).to.equal ('sally');
                    expect (o.getAge ()).to.equal (24);

                    // Confirm internal methods work.
                    expect (o.modifyName ('ms')).to.equal ('ms sally');
                    expect (o.getAge (10)).to.equal (34);
                    done ();
                }
            })
        })
        it ('should allow an object to extend from many others.', function (done) {
            var o;

            tm.load ({
                list: [
                    '/src/test/simple/sample/ExtendFromMultipleObjects.js',
                ],
                done: function () {
                    o = tm.new ('test.simple.ExtendFromMultipleObjects', {name: 'sally', age: 24});
                    expect (o.getCity).to.exist;
                    expect (o.getAge (5)).to.equal (29);
                    expect (o.getCity ()).to.equal ('Phoenix');
                    expect (o.getZipCode ()).to.equal ('85283');
                    done ();
                }
            })
        })
        it ('should keep meta info on objects extend from.', function () {
            var o;

            o = tm.new ('test.simple.ExtendFromMultipleObjects');
            expect (o.getInfo ('extends')).to.equal ('test.simple.Object1, test.simple.ExtendFromObject, test.simple.Object2, test.simple.ExtendFromMultipleObjects');
        })
        it ('should throw error if any inherited parent does not have a setup method.', function () {
            var o;

            tm.add ('test.simple.InheritNoSetupRef', function (o) {
            });

            tm.add ('test.simple.InheritNoSetup', ['test.simple.InheritNoSetupRef'], function (o) {
            });

            try {
                o = tm.new ('test.simple.InheritNoSetup');
            }
            catch (err) {
                expect (err.message).to.equal ('Unable to extend <test.simple.InheritNoSetup> from the <test.simple.InheritNoSetupRef> object. The <test.simple.InheritNoSetupRef> object does not have a publicly shared "setup" method.');
            }
        });
        it ('should throw error if any inherited parent does not exist.', function () {
            var o;

            tm.add ('test.simple.ExtendNonExist', ['test.simple.ErrorExtendNonExists'], function () {
            });

            try {
                o = tm.new ('test.simple.ExtendNonExist');
            }
            catch (err) {
                expect (err.message).to.equal ('Unable to extend <test.simple.ExtendNonExist>. The inheritance parent <test.simple.ErrorExtendNonExists> does not exist.');
            }
        })
        it ('should throw error if any inherited parent does not return the shared object.', function () {
            var o;

            tm.add ('test.simple.ErrorObj1', function (o) {
            });

            tm.add ('test.simple.ExtendReturnError', ['test.simple.ErrorObj1'], function (o) {
            });

            try {
                o = tm.new ('test.simple.ExtendReturnError');
            }
            catch (err) {
                expect (err.message).to.equal ('Extending from the <test.simple.ErrorObj1> object does not return the shared "o" object.');
            }
        })
        it ('should throw error if replacing existing inherited shared method without using the override () method.', function () {

            tm.add ('test.simple.OverrideRef', function (o, p) {
                o.sharedTestMethod = function () {
                }
            });

            tm.add ('test.simple.OverrideMethod', ['test.simple.OverrideRef'], function (o, p) {
                o.sharedTestMethod = function () {
                }
            });


            try {
                o = tm.new ('test.simple.OverrideMethod');
            }
            catch (err) {
                expect (err.message).to.equal ('Incorrectly overriding the <test.simple.OverrideMethod> object\'s pre-existing "sharedTestMethod" method. To override this method use the shared area\'s override () method.');
            }
        })
        it ('should throw error if replacing existing inherited private method without using the override () method.', function () {
            var o;

            tm.add ('test.simple.PrivateOverrideRef', function (o, p) {
                p.privateTestMethod = function () {
                }
            });

            tm.add ('test.simple.PrivateOverrideMethod', ['test.simple.PrivateOverrideRef'], function (o, p) {
                p.privateTestMethod = function () {
                }
            });


            try {
                o = tm.new ('test.simple.PrivateOverrideMethod');
            }
            catch (err) {
                expect (err.message).to.equal ('Incorrectly overriding the <test.simple.PrivateOverrideMethod> object\'s pre-existing "privateTestMethod" method. To override this method use the private area\'s override () method.');
            }
        })
        it ('should allow existing inherited private method to be replaced with overridde method.', function () {
            var testData, obj1, obj2, priv, privOverride;

            testData = window._testData.override;
            testData.private = {
                count: 0,
            };
            testData = testData.private;

            tm.add ('test.simple.OverrideOrigPrivateRef', function (o, p) {
                priv = p;

                p.privateTestMethod = function () {
                    testData.count = parseInt (testData.count) + 1;
                }

                o.testMethod = function (modifyValue) {
                    p.privateTestMethod (modifyValue);
                }
            });

            tm.add ('test.simple.OverrideOrigPrivate', ['test.simple.OverrideOrigPrivateRef'], function (o, p) {
                p.override ({
                    privateTestMethod: function (original, modifyValue) {
                        if (modifyValue) {
                            testData.context = this;
                            testData.count = modifyValue;
                        }
                        else {
                            testData.count = 100;
                        }

                        // Call the original method.
                        original ();
                    }
                });
            });

            obj1 = tm.new ('test.simple.OverrideOrigPrivateRef');
            obj2 = tm.new ('test.simple.OverrideOrigPrivate');

            // Run the original method.
            obj1.testMethod ();
            expect (testData.count).to.equal (1);

            // Run the modified method.
            obj2.testMethod ();
            expect (testData.count).to.equal (101);

            obj2.testMethod (500);
            expect (testData.count).to.equal (501);
            expect (testData.context).to.equal (priv);

            expect (priv.override).to.not.exist;
        })
        it ('should allow existing inherited shared method to be replaced with override method.', function () {
            var testData, obj1, obj2;

            testData = window._testData.override;
            testData.shared = {
                count: 0,
            };
            testData = testData.shared;

            tm.add ('test.simple.OverrideOrigSharedRef', function (o, p) {
                o.sharedTestMethod = function () {
                    testData.count = parseInt (testData.count) + 1;
                }
            });

            tm.add ('test.simple.OverrideOrigShared', ['test.simple.OverrideOrigSharedRef'], function (o, p) {
                o.override ({
                    sharedTestMethod: function (original, modifyValue) {
                        if (modifyValue) {
                            testData.context = this;
                            testData.count = modifyValue;
                        }
                        else {
                            testData.count = 100;
                        }

                        // Call the original method.
                        original ();
                    }
                });
            });

            obj1 = tm.new ('test.simple.OverrideOrigSharedRef');
            obj2 = tm.new ('test.simple.OverrideOrigShared');

            // Run the original method.
            obj1.sharedTestMethod ();
            expect (testData.count).to.equal (1);

            // Run the modified method.
            obj2.sharedTestMethod ();
            expect (testData.count).to.equal (101);

            obj2.sharedTestMethod (500);
            expect (testData.count).to.equal (501);
            expect (testData.context).to.equal (obj2);

            expect (obj2.override).to.not.exist;
        })
        it ('should allow several levels of overriding a method.', function () {
            var list = [];
            
            tm.add ('obj1', function (o, p, d) {
                o.setup = function (config) {
                }
                o.test = function (data) {
                    list.push ('-------------------');
                    list.push ('obj 1');
                }
            })
            
            tm.add ('obj2', ['obj1'], function (o, p, d) {
                o.setup = function (config) {
                }
                o.override ({
                    test: function (original, data) {            
                        original ()
                        list.push ('obj 2');
                    }
                })
            })
            
            tm.add ('obj3', ['obj2'], function (o, p, d) {
                o.setup = function (config) {
                }
                o.override ({
                    test: function (original, data) {
                        original ()
                        list.push ('obj 3');
                    }
                })
            })
            
            tm.add ('obj4', ['obj3'], function (o, p, d) {
                o.setup = function (config) {
                }
                o.override ({
                    test: function (original, data) {
                        original ()
                        list.push ('obj 4');
                    }
                })
            })
            
            
            var a = {};
            a.obj1 = tm.new ('obj1');
            a.obj2 = tm.new ('obj2');
            a.obj3 = tm.new ('obj3');
            a.obj4 = tm.new ('obj4');
            
            a.obj1.test ();
            a.obj2.test ();
            a.obj3.test ();
            a.obj4.test ();
            
            console.log ('list:', list);
            
            expect (list).to.eql ([
                '-------------------', 
                'obj 1',
                '-------------------', 
                'obj 1',
                'obj 2',
                '-------------------', 
                'obj 1',
                'obj 2',
                'obj 3',
                '-------------------', 
                'obj 1',
                'obj 2',
                'obj 3',
                'obj 4'
            ]);
        })
        it ('should throw error if overridding a private method that does not exist.', function () {
            tm.add ('test.simple.ErrorOverrideOrigPrivateRef', function (o) {
            });

            tm.add ('test.simple.ErrorOverrideOrigPrivate', ['test.simple.ErrorOverrideOrigPrivateRef'], function (o, p) {
                p.override ({
                    privateTestMethod: function () {
                    }
                });
            });

            try {
                obj1 = tm.new ('test.simple.ErrorOverrideOrigPrivate');
            }
            catch (err) {
                expect (err.message).to.equal ('Unable to override "privateTestMethod" method in the private area because it does not exist in the <test.simple.ErrorOverrideOrigPrivate> object\'s private area.');
            }
        });
        it ('should throw error if overridding a shared method that does not exist.', function () {

            tm.add ('test.simple.ErrorOverrideOrigSharedRef', function (o) {
            });

            tm.add ('test.simple.ErrorOverrideOrigShared', ['test.simple.ErrorOverrideOrigSharedRef'], function (o, p) {
                o.override ({
                    sharedTestMethod: function (original, modifyValue) {
                    }
                });
            });

            try {
                obj2 = tm.new ('test.simple.ErrorOverrideOrigShared');
            }
            catch (err) {
                expect (err.message).to.equal ('Unable to override "sharedTestMethod" method in the shared area because it does not exist in the <test.simple.ErrorOverrideOrigShared> object\'s shared area.');
            }
        });
        it ('should provide a debug tree of inheritance info.')
    })

    describe ('Utilities', function () {
        it ('should allow getting the Javascript and Tamed types.');
        it ('should allow merging or JS literal objects.');
    })
});
