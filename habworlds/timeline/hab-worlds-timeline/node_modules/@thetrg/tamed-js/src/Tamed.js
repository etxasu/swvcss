'use strict';

// Check if we are in a NodeJs environment.
if (typeof window == 'undefined') {
    var jsdom = require('jsdom');
    var window = new jsdom.JSDOM ('').window;
    global.window = window;
    global.document = window.document;
    global.window.isNodeJs = true;
}

// Poly fill

// Object.assign
// ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of function is 2
            'use strict';
            if (target == null) { // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }
            
            var to = Object(target);
            
            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];
                
                if (nextSource != null) { // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}

// Boot up the Tamed object.
(function () {
    // Attach the Tamed object to the window.
    if (!window.tm) {
        var o, cache, config, db, isReady, preload, simple;

        // Create the Tamed object.
        isReady = false;
        config = {
            start: {},
        };
        cache = {
            loaded: {},
            object: {}
        };
        db = {};

        preload = {
            object: [],
            load: [],
        };

        o = {
            _info: {
                type: '/tamed-js/Tamed.js',
                version: '1.0.0',
                coreObject: true,
            },
            _data: {},
            _method: {
                _shared: {
                    bootup: function (internal) {
                        isReady = true;
                        var dom, html, tmConfig;

                        // Clear out setup items.
                        delete o._method._shared.bootup;
                        delete o._method._shared.getPreloader;

                        var key, list;
                        list = window._tmConfig;
                        for (key in list) {
                            window._tmConfig [key] = null;
                            delete window._tmConfig [key];
                        }

                        // Attach the shared methods to the object.
                        buildStructure ({o: o, data: {target: o._data, isData: true}});
                        buildStructure ({o: o, data: {target: o._method}});
                        setupQuickReference ({o: o, data: {target: o}});

                        // Ensure we have a Tamed area.
                        dom = document.querySelector ('#tamed-area');
                        if (!dom) {
                            dom = document.createElement ('div');
                            dom.id = 'tamed-area';
                            document.body.appendChild (dom);

                            html = [
                                '<div id="tamed-js-area" style="display: none">',
                                    '<div id="script-area" style="display: none">',
                                        '<div id="script-dynamic">',
                                        '</div>',
                                        '<div id="script-static">',
                                        '</div>',
                                    '</div>',
                                '</div>',
                                '',
                            ].join ('');

                            dom.innerHTML = html;
                        }

                        // Load the preloaded loaders to load.
                        simple.bootup (internal);

                        // Add the preloaded objects for the object cache.
                        preload.object.forEach (function (item) {
                            cache.object [item.name] = item.object;
                        })

                        // Clear out the preload list.
                        preload.object = null;
                        preload.load = null;

                        // Run any methods for readyness.
                        if (config && config.start && config.start.list) {
                            var delay;

                            delay = config.start.delay;
                            if (!delay) { delay = 0; }

                            setTimeout (function () {
                                config.start.list.forEach (function (item) {
                                    // Run each start method.
                                    item.apply (o, []);
                                });
                                config.start.list = null;
                            }, delay);
                        }

                        return o;
                    },
                    copy: function () {
                    },
                    buildStructure: buildStructure,
                    define: function () {
                    },
                    emulateKey: function (data) {
                        // ref: http://keycode.info/
                        // console.log ('- firing tab...');
                        var evnt;

                        if (!data) { data = {}; }
                        if (!data.key) { data.key = 'tab'; }
                        // console.log ('key:', data.key);

                        if (data.key == 'tab') {
                            data.char = '\t';
                            data.keyCode = 9;
                        }
                        else {
                            data.char = data.key;
                            if (!data.keyCode) {
                                data.keyCode = data.key.toUpperCase ().charCodeAt (0);
                            }
                        }

                        // data.char = 'a';
                        // data.key = 'a';
                        // data.keyCode = 65;
                        if (!data.shiftKey) { data.shiftKey = false; }
                        data.bubbles = true;
                        data.cancelable = true;

                        function chromeHack (keyEvnt) {
                            // ref: https://stackoverflow.com/a/23812767
                            // ref: https://stackoverflow.com/a/10520017
                            // Chrome Hack
                            Object.defineProperty(keyEvnt, 'keyCode', {
                                        get : function() {
                                            return data.keyCode;
                                        }
                            });
                            Object.defineProperty(keyEvnt, 'which', {
                                        get : function() {
                                            return data.keyCode;
                                        }
                            });
                            return keyEvnt;
                        }

                        var evnt = chromeHack (new KeyboardEvent ('keydown', data));
                        document.body.dispatchEvent (evnt);

                        var evnt = chromeHack (new KeyboardEvent ('keyup', data));
                        document.body.dispatchEvent (evnt);
                    },
                    generateTmId: function (base) {
                        var id;
                        // var data, id, timestamp, type;

                        // // Set object context.
                        // // o = data.o;
                        // data = data.data;
                        //
                        // // Code body.
                        // timestamp = data.timestamp;
                        // if (!timestamp) { timestamp = moment (); }
                        //
                        // type = data.type;
                        // id = '' +
                        //     type + ':' +
                        //     timestamp.format ('YYYY-MM-DD-HH-mm-ss-SSS') + ':' +
                        //     _tm.randomString ({o: _tm, data: {length: 8}});
                        //
                        // // NOTE: In the future add a way to ensure unique
                        // // ids by maybe tracking the timestamp or last
                        // // couple id's in the last 2 seconds generated?
                        if (!base) {
                            base = '';
                        }
                        else {
                            base = base + '-';
                        }

                        id = base + Date.now () + '-' + tm.randomString ();
                        return id;
                    },
                    getData: function (key) {
                        return db [key];
                    },
                    getInfo: function (useSimple) {
                        return {
                            version: o._info.version,
                        }
                    },
                    getPreloader: function (useSimple) {
                        if (useSimple) {
                            return simple.getPreloader ();
                        }
                        return preload;
                    },
                    getStartList: function () {
                        o._method._shared.getStartList = undefined;
                        delete o._method._shared.getStartList;

                        return config.start;
                    },
                    isReady: function () {
                        return isReady;
                    },
                    merge: merge,
                    randomString: function (data) {
                        // ref: https://stackoverflow.com/a/1349426
                        var end, i, possible, text;

                        // Set object context.
                        // o = data.o;
                        if (!data) { data = {}; }
                        if (!data.length) { data.length = 20; }

                        data = data;

                        text = '';
                        possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

                        end = data.length;
                        for (var i = 0; i < end; i++) {
                            text += possible.charAt (Math.floor (Math.random () * possible.length));
                        }

                        return text;
                    },
                    setData: function (key, value) {
                        db [key] = value;
                    },
                    setupQuickReference: setupQuickReference,
                    setSimpleTamed: function (simpleObj) {
                        window.tm.setSimpleTamed = null;
                        delete window.tm.setSimpleTamed;

                        // Build out the simple tamed object.
                        simple = simpleObj ();
                        merge ({o: o, data: {
                            source: simple,
                            target: o._method._shared,
                            keepOriginal: true,
                        }});
                    },
                    start: function (callback) {
                        // var o;

                        if (isReady) {
                            // Run each start method.
                            callback.apply (o, []);
                        }
                        else {
                            if (!config) { config = {}; }
                            // o = config;
                            // if (!config.start) { config.start = {}; }
                            if (!config.start.list) { config.start.list = []; }

                            config.start.list.push (callback);
                        }
                    },
                }
            },
        };

        o._method._shared.run = o._method._shared.start;

        // Methods that need to pre-exist in
        // order to create Tamed.
        var buildStructure = function (data) {
            var cursor;

            // Set the bag defaults.
            if (!data.o) {data.o = window._tm;}
            if (!data.data) {data.data = {};}

            // Set object context.
            // o = data.o;
            data = data.data;
            cursor = data.target;

            if (data.isData) {
                if (!cursor._constant) { cursor._constant = {}; }
            }
            else {
                if (!cursor._event) { cursor._event = {}; }
            }

            if (!cursor._unique) { cursor._unique = {}; }
            if (!cursor._private) { cursor._private = {}; }
            if (!cursor._shared) { cursor._shared = {}; }
            if (!cursor._dynamic) { cursor._dynamic = {}; }
        }

        var kill = function () {
            var item, key, list, o;

            o = this;
            list = o;
            for (key in list) {
                o [key] = null;
                delete o [key];
            }
        }

        var merge = function (data) {
            var item, keepOriginal, key, list, o, source, target;

            // Set object context.
            // o = data.o;
            data = data.data;

            source = data.source;
            target = data.target;
            keepOriginal = data.keepOriginal;

            if (source && target) {
                list = source;
                for (key in list) {
                    if (typeof list [key] === 'object') {
                        // Duplicate the keys of nested objects.
                        if (!target [key]) { target [key] = {}; }

                        if (keepOriginal === true) {
                            if (target [key] === undefined) {
                                merge ({o: o, data: {source: list [key], target: target [key]}});
                            }
                        }
                        else {
                            merge ({o: o, data: {source: list [key], target: target [key]}});
                        }
                    }
                    else {
                        // Duplicate the references or values.
                        if (keepOriginal === true) {
                            if (target [key] === undefined) {
                                target [key] = list [key];
                            }
                        }
                        else {
                            target [key] = list [key];
                        }
                    }
                }
            }

            return target;
        }

        var setup = function () {
            var tmConfig;

            // Set the start callback methods to run once
            // Tamed has booted up.
            tmConfig = Object.assign ({}, window._tmConfig);
            if (tmConfig && tmConfig.test && tmConfig.test.start) {
                tmConfig.test.start ();
            }
            else {
                // console.log ('- Booting up Tamed...');
                o._method._shared.bootup ();
            }
        }

        var setupQuickReference = function (data) {
            var target;

            // Set the bag defaults.
            if (!data.o) {data.o = window._tm;}
            if (!data.data) {data.data = {};}

            // Create a context for quick lookup.
            // o = data.o;
            data = data.data;
            target = data.target;

            target._dc   = target._data._constant;
            target._du   = target._data._unique;
            target._dp   = target._data._private;
            target._ds   = target._data._shared;

            target._me   = target._method._event;
            target._mu   = target._method._unique;
            target._mp   = target._method._private;
            target._ms   = target._method._shared;
        }

        // Create the Tamed object.
        if (window.isNodeJs) {
            window.tm = o._method._shared;
            global.tm = window.tm;
            // isReady = true;
            tm.boot = function () {
                tm.boot = null;
                delete tm.boot;
                setup ();
                return tm;
            }
            // setTimeout (function () { setup (); }, 1)
        }
        else {
            window.tm = o._method._shared;
            
            // When iframed and iframed, there is a potential the 
            // 'onload' event will not fire if content is not loaded 
            // by normal means.
            // ref: https://stackoverflow.com/a/20624274/3268255
            if (window.self !== window.top) {
                var timer = setInterval (function () {
                    if (window.document.body &&  
                        window.document.body.children &&
                        window.document.body.children.length > 0) {
                            
                        console.log ('- Tamed booting up:', Date.now ());
                        setup ();
                        clearInterval (timer);
                        
                        return;
                    }
                }, 100);
            }
            else {
                window.addEventListener ('load', setup);
            }
        }

        // Check if Cypress test environment is running.
        if (window.Cypress) {
            window.Cypress.tm = window.tm;
        }
    }
}) ()
