'use strict';

// Boot up the Tamed object.
tm.setSimpleTamed (function () {
    var o, dataArea, cache, config, preload;

    // Create the Tamed object.
    config = {};
    cache = {
        object: [],
        loaded: [],
    };
    preload = {
        name: 'simple',
        object: [],
        load: [],
    }

    dataArea = {};

    // Attach the Tamed object to the window.
    o = {
        add: function (name, extendList, object) {
            // console.log ('cache:', cache.object);
            if (!Array.isArray (extendList)) {
                object = extendList;
                // extendList = null;
            }

            if (!tm.isReady ()) {
                preload.object.push ({name: name, extendList: extendList, object: object});
                return window.tm;
            }

            if (!cache.object [name]) {
                if (extendList && extendList !== object) {
                    object._extendList = extendList;
                }

                // console.log ('type:', (typeof object));
                cache.object [name] = object;
                return window.tm;
            }

            // Error could not find object.
            throw new Error ('Object "' + name + '" already defined.');
            return window.tm;
        },
        addHtml: function (name, template) {
            if (config.templater) {
                return config.templater.addHtml (name, template)
            }
        },
        bootup: function (internal) {
            var loader;

            // // Create the loader.
            // if (config.loader) {
            //     config.loader (preload)
            //     loader = 'trg.loader.simple.Loader';
            // }

            // Add references for testing.
            if (internal) {
                internal.cache = cache;
            }

            // Load the preloaded loaders to load.
            if (preload.load [0]) {
                o.load (preload.load [0]);
            }

            // Add the preloaded objects for the object cache.
            preload.object.forEach (function (item) {
                o.add (item.name, item.extendList, item.object);
            })

            // // If a loader is specified, use it.
            // if (loader) {
            //     loader = tm.new (loader);
            // }

            // Clear out the preload list.
            preload.object = null;
            preload.load = null;

            o.bootup = null;
            delete o.bootup;
        },
        emptyFunc: function () {},
        getContent: function (data) {
            if (config.loader) {
                return config.loader.getContent (data);
            }
        },
        getData: function (name) {
            return dataArea [name];
        },
        getFuncParams: function (func) {
            if (tm.getType (func) == 'Function') {
                func = func.toString ();
                func = func.substring (func.indexOf ('(') + 1);
                func = func.substring (0, func.indexOf (')'));
                func = func.split (',');
                return func;
            }
            return [];
        },
        getHtmlTemplater: function () {
            return config.templater;
        },
        getLineInfo: function (noFrame, offset) {
            var end, line, start;
            line = getLogLine (offset);

            start = '[';
            end = ']'
            if (noFrame) {
                start = '';
                end = '';
            }

            return start + line.file + ':' + line.number + ':' + line.column + end;
        },
        getPreloader: function (useSimple) {
            return preload;
        },
        getType: function (item) {
            var index1, index2, type;
            
            type = 'UnKnown';
            if (item === undefined) {
                type = 'Undefined';
            }
            else if (item.getInfo) {
                type = item.getInfo ('type');
            }
            else if (item === null) {
                type = 'Null';
            }
            else if (item === Infinity) {
                type = 'Infinity';
            }
            else if (item === Math) {
                type = 'Math';
            }
            else {
                type = item.constructor.toString ();
                index1 = type.indexOf (' ');
                index2 = type.indexOf ('(');
                type = type.substring (index1, index2).trim ();
            }

            if (type === 'Number') {
                if (isNaN (item)) {
                    type = 'NaN'
                }
                else if (item.toString ().indexOf ('.') > -1) {
                    type = 'Decimal';
                }
                else {
                    type = 'Integer';
                }
            }

            return type;
        },
        html: function (name, template) {
            if (config.templater) {
                return config.templater.html (name, template)
            }
        },
        isLoaded: function (name) {
            if (cache.object [name]) {
                return true;
            }
            return false;
        },
        js: function (name, data) {
            var item;
            if (data === undefined) { data = name }

            if (tm.getType (data) == 'Function') {
                data = data ();
            }

            if (tm.getType (name) == 'String') {
                tm.setData (name, data);
            }
            return data;
        },
        load: function (data) {
            var count, end, errorList, extension, i, item, list, nonJsList, loaded, url;
            // var end, extension, i, item;

            if (!tm.isReady ()) {
                if (!preload.load.length) {
                    var origDone;

                    // Convert the done method into an array of callbacks.
                    if (!data.done) { data.done = []; }
                    if (!Array.isArray (data.done)) {
                        origDone = data.done;
                        data.done = [
                            origDone,
                        ]
                    }

                    // Set this loader as the first loader item.
                    preload.load.push (data);
                    return window.tm;
                }

                // Push the load data into the pre-existing load data.
                var loadDoneList, loadList;

                loadDoneList = preload.load [0].done;
                loadList = preload.load [0].list;

                loadList.push.apply (loadList, data.list);
                if (data.done) {
                    loadDoneList.push (data.done);
                }

                // Pull out any item that is not a javascript file.
                return window.tm;
            }

            function checkIfDone () {
                var info, error;

                if (count >= list.length) {
                    var error;

                    if (errorList.length) { error = errorList; }
                    if (data.done) {
                        info = {
                            count: count,
                            list: list,
                            loaded: loaded,
                            nonJsList: nonJsList,
                            errorList: errorList,
                            force: data.force,
                        }

                        if (config.loader) {
                            info.done = data.done;
                            config.loader.load (info);
                        }
                        else {
                            if (Array.isArray (data.done)) {
                                data.done.forEach (function (item) {
                                    item (info);
                                })
                            }
                            else {
                                data.done (info);
                            }
                        }
                    }
                }
            }

            function fileDone (file) {
                var info;
                // Increment the count and make check if all
                // the dependent files have been loaded.
                loaded [file] = true;
                cache.loaded [file] = true;

                count++;
                checkIfDone ();
            }

            function loadScript (file) {
                var dom, parent;

                // Attach the script file to the page.
                if (!window.isNodeJs) {
                    parent = document.querySelector ('#tamed-area #script-area #script-dynamic');
                    dom = document.createElement ('script');
                    dom.src = file;

                    dom.onload = function (evnt) {
                        fileDone (file);
                    }

                    dom.onerror = function (evnt) {
                        errorList.push (Error ('Unable to load file: ' + file));
                        fileDone (file);
                    }

                    try {
                        parent.appendChild (dom);
                    }
                    catch (err) {
                        errorList.push (Error ('Unable to load file: ' + file + '\n' + err.message));
                    }

                    // Track the files that are being loaded.
                    loaded [file] = false;
                    cache.loaded [file] = false;
                }
                else {
                    // var dir = process.cwd () + '/node_modules/express-tamed';
                    // Load the tamed file through NodeJs.

                    // Track the files that are being loaded.
                    loaded [file] = false;
                    cache.loaded [file] = false;

                    try {
                        console.log ('- loading:', file);
                        // console.log ('*** here', process.cwd () + file + 'fds');
                        // console.log ('*** here', process.cwd () + file); process.exit ();
                        require (file);
                        fileDone (file);

                        loaded [file] = true;
                        cache.loaded [file] = true;
                    }
                    catch (err) {
                        var msg = 'Unable to load file: ' + file + '\n' + err.message;
                        errorList.push (Error (msg));
                        console.log ('\x1b[1m\x1b[38;5;15m\x1b[48;5;9m ' + 'ERROR:\x1b[0m ' + msg + '')
                        fileDone (file);
                    }
                }
            }

            errorList = [];
            loaded = {};
            count = 0;
            list = data.list;
            nonJsList = [];

            if (!list) { list = []; }

            if (!Array.isArray (list)) {
                list = [list];
            }

            end = list.length;
            for (i = 0; i < end; i++) {
                item = list [i];

                url = item;
                if (tm.getType (item) === 'Object') { url = item.url }

                extension = url.substring (url.lastIndexOf ('.') + 1)
                if (extension !== 'js') {
                    nonJsList.push (item);
                    count++;
                }
                else {
                    // Make sure we aren't already loading the item.
                    if (loaded [item] === undefined && !cache.loaded [item]) {
                        loadScript (item);
                    }
                    else {
                        count++;
                    }
                }
            }

            // If nothing is loaded call the done callback.
            if (Object.keys (loaded).length == 0 && data.done) {
                checkIfDone ();
            }
        },
        merge: function (data) {
            var item, keepOriginal, key, list, obj, source, target;

            // Set object context.
            // o = data.o;
            if (!data.o) {
                data = data;
            }
            else {
                obj = data.o;
                data = data.data;
            }

            source = data.source;
            target = data.target;
            keepOriginal = data.keepOriginal;

            if (source && target) {
                list = source;
                for (key in list) {
                    if (typeof list [key] === 'object') {
                        // Duplicate the keys of nested objects.
                        if (!target [key]) { target [key] = {}; }

                        if (keepOriginal === true) {
                            if (target [key] === undefined) {
                                // merge ({o: o, data: {source: list [key], target: target [key]}});
                                o.merge ({source: list [key], target: target [key]});
                            }
                        }
                        else {
                            // merge ({o: o, data: {source: list [key], target: target [key]}});
                            o.merge ({source: list [key], target: target [key]});
                        }
                    }
                    else {
                        // Duplicate the references or values.
                        if (keepOriginal === true) {
                            if (target [key] === undefined) {
                                target [key] = list [key];
                            }
                        }
                        else {
                            target [key] = list [key];
                        }
                    }
                }
            }

            return target;
        },
        new: function (name, config) {
            var base, built, o, obj, result;
            // console.log ('cache:', cache.object);

            if (cache.object [name]) {
                if (!config) { config = {}; }
                base = cache.object [name];

                // if (base._built) {
                if (base._built === true) {
                    built = base._built;
                    base._buildCount++;

                    obj = Object.assign ({}, built);
                    obj.info = {
                        type: built.info.type,
                        id: tm.generateTmId () + '-' + uuidv4 () + '-' + base._buildCount,
                        // id: tm.generateTmId () + '-' + base._buildCount,
                        createCount: base._buildCount,
                        extendList: built.info.extendList,
                        usingCachedBuild: true,
                    };

                    // Allow metadata about object.
                    obj.o.getInfo = wrapGetInfo (obj);

                    // Remove the data.
                    obj.d = {
                        _config: config
                    };

                    // var end, i, item, key, list;
                    // list = obj.setupList;
                    // end = list.length;
                    //
                    // for (i = 0; i < end; i++) {
                    //     item = list [i];
                    //     item.apply (obj.o, [obj.d, config]);
                    // }
                }
                else {
                    // Build the new object's construction
                    // context object.
                    if (!base._buildCount) { base._buildCount = 0; }
                    base._buildCount++;

                    obj = {
                        info: {
                            type: name,
                            id: tm.generateTmId () + '-' + uuidv4 (),
                            // id: tm.generateTmId () + '-' + 1,
                            createCount: base._buildCount,
                            extendList: [],
                            usingCachedBuild: false,
                        },
                        
                        // Externally shared public methods.
                        o: {
                        },
                        
                        // Internally shared private methods.
                        p: {},
                        
                        // Internally event area methods.
                        e: {
                        },

                        setupList: [
                        ],

                        override: {
                            o: {},
                            p: {},
                            e: {},
                        },

                        // // Externally shared public methods.
                        // o: {
                        //     // override: createOverrideMethod (obj, 'o'),
                        //     // override: function (overrideObj) {
                        //     //     var item, key, list, target;
                        //     // 
                        //     //     list = overrideObj;
                        //     //     target = obj.override.o;
                        //     //     for (key in list) {
                        //     //         target [key] = list [key];
                        //     //     }
                        //     // },
                        // },
                        // 
                        // // Internally shared private methods.
                        // p: {
                        //     // _override: {},
                        //     // override: override: createOverrideMethod ('p'),
                        //     // override: function (overrideObj) {
                        //     //     var item, key, list, target;
                        //     // 
                        //     //     list = overrideObj;
                        //     //     target = obj.override.p;
                        //     //     for (key in list) {
                        //     //         target [key] = list [key];
                        //     //     }
                        //     // },
                        // },
                    }
                    
                    if (config._info && !config.uniqueId) { 
                        obj.info.id = config._info.id; 
                    }

                    // Remove the data.
                    obj.o.override = createOverrideMethod (obj, 'o');
                    obj.p.override = createOverrideMethod (obj, 'p');
                    obj.e.override = createOverrideMethod (obj, 'e');
                    obj.d = {
                        _config: config,
                        _info: {
                            id: obj.info.id,
                            type: obj.info.type,
                        }
                    };
                    
                    obj.o._setupStackList = [];
                    obj.e._setupStackList = [];

                    // Allow metadata about object.
                    obj.o.getInfo = wrapGetInfo (obj);
                    obj.o.extendsFrom = wrapExtendsFrom (obj);

                    // Grab the extension list and begin
                    // extending the object.
                    extend (name, obj, base._extendList);

                    // Run the final object constructor.
                    runConstructor (base, name, obj, name);

                    // // Wrap each override method.
                    // wrapOverrideMethod (name, 'shared', obj.override.o, obj.o);
                    // wrapOverrideMethod (name, 'private', obj.override.p, obj.p);
                    // wrapOverrideMethod (name, 'event', obj.override.e, obj.e);

                    // // Cached to construction context for faster
                    // // generation of instances in the future.
                    // base._built = Object.assign ({}, obj);
                    // base._built.d = {};

                    // Remove the override areas.
                    delete obj.o.override;
                    delete obj.p.override;
                    
                    if (obj.e) {
                        delete obj.e.override;
                    }
                }

                obj.o.toString = wrapToString (obj);
                obj.o._kill = wrapKill (obj);

                // Run the setup.
                var end, i, item, key, list;
                list = obj.setupList;
                end = list.length;

                for (i = 0; i < end; i++) {
                    item = list [i];
                    item.apply (obj.o, [config]);
                }
                
                // If using chirp, fire the prepare event.
                if (obj.e && obj.e.setup) {
                    obj.e.setup (config);
                    delete obj.e.setup;
                }
                
                // Go through the setup stack list.
                list = obj.o._setupStackList;
                end = list.length;
                for (i = 0; i < end; i++) {
                    item = list [i];
                    item = obj.o [item];
                    if (item) {
                        item.apply (obj.o, [config]);
                        obj.o [item] = null;
                        delete obj.o [item];
                    }
                }
                obj.o._setupStackList = null;
                delete obj.o._setupStackList;
                
                // // Go through the setup stack list for commands
                // list = obj.e._setupStackList;
                // end = list.length;
                // for (i = 0; i < end; i++) {
                //     item = list [i];
                //     item = obj.e [item];
                //     if (item) {
                //         item.apply (obj.e, [config]);
                // 
                //     }
                // }
                // obj.o._setupStackList = null;
                // delete obj.o._setupStackList;
                
                if (obj.e && obj.e._setup) {
                    obj.e._setup (config);
                    delete obj.e._setup;
                }

                return obj.o;
            }
            else {
                throw new Error ('The simple Tamed "' + name + '" object does not exist. It has not been loaded.');
            }
        },
        resolvePath: function (path) {
            if (!path) { path = ''; }
            path = path.trim ();
            
            if (path [0] == '/') {
                path = '@public/' + path;
            }
            
            if (path.indexOf ('@public/') == 0) {
                path = path.replace ('@public/', '/public/');
            }
            return path;
        },
        sendTestResult: function (runner) {
            var data, end, i, item, key, list, parent, queryString;
            
            parent = window.parent;
            if (window !== parent) {
                
                // Pull the target parent from the url.
                // console.log ('*** what:', document.URL);
                // console.log ('query string:', queryString);
                // url = document.URL; //window.location.href;
                
                queryString = document.URL.split ('?') [1];
                // console.log ('query string:', document.URL);
                // console.log ('query string:', queryString);      
                
                if (queryString) {
                    list = queryString.split ('&');
                    end = list.length;
                    queryString = {};
                    
                    for (i = 0; i < end; i++) {
                        item = list [i];
                        item = item.split ('=');
                        queryString [item [0]] = decodeURIComponent (item [1]);
                    }
                    
                    // console.log ('*** query string:', + list);
                    // console.log ('*** query string:', + queryString);
                    
                    if (queryString.parentHost) {
                        // Get the runner data.
                        // data = {name: 'bob', age: 32};
                        // console.log ('runner:', runner);
                        // data = {
                        //     failures: runner.failures,
                        // };
                        
                        // Send the message to the parent window.
                        parent.postMessage (runner.stats, queryString.parentHost);
                    }
                }
            }
        },
        setContent: function (data) {
            if (config.loader) {
                config.loader.setContent (data);
            }
            return data;
        },
        setData: function (name, data) {
            dataArea [name] = data;
        },
        setHtmlTemplater: function (htmlTemplater) {
            config.templater = htmlTemplater;

            // Remove the ability to set a loader.
            tm.setHtmlTemplater= null;
            delete tm.setHtmlTemplater;
        },
        setLoader: function (loader) {
            config.loader = loader;

            // Remove the ability to set a loader.
            tm.setLoader = null;
            delete tm.setLoader;
        },
        setPlugin: function (name, func) {
            tm [name] = func;
        },
        store: {},
    }
    
    var createOverrideMethod = function (obj, area) {
        return function (overrideObj) {
            var item, key, list, target;

            list = overrideObj;
            target = obj.override [area];
            for (key in list) {
                target [key] = list [key];
            }
        }
    }

    var wrapExtendsFrom = function (obj) {
        return function (toCompare) {
            var extend, type;

            extend = obj.o.getInfo ('extends').split (', ');
            type = (typeof toCompare);

            if (type === 'object') {
                if (toCompare.getInfo) {
                    toCompare = toCompare.getInfo ('type');
                }
            }

            type = (typeof toCompare);
            if (type === 'string') {
                if (extend.indexOf (toCompare) > -1) {
                    return true;
                }
            }

            return false;
        }
    }

    var wrapToString = function (obj) {
        return function () {
            return obj.info.type + '-' + obj.info.id;
        }
    }

    var wrapGetInfo = function (obj) {
        var info = obj.info;

        return function (key) {
            var value;

            if (key == 'extends') {
                value = info ['extendList'];
                value = value.join (', ');
            }
            else {
                value = info [key];
            }

            return value;
        }
    }

    var wrapMethod = function (context, original, override) {
        return function () {
            var args;

            args = Array.prototype.slice.call (arguments);
            args = [original].concat (args);
            return override.apply (context, args);
        }
    }

    var wrapOverrideMethod = function (name, area, source, target) {
        var item, key, list;

        list = source;
        for (key in list) {
            if (target [key]) {
                target [key] = wrapMethod (target, target [key], list [key]);
            }
            else {
                throw new Error ('Unable to override "' + key + '" method in the ' + area + ' area because it does not exist in the <' + name + '> object\'s ' + area + ' area.');
            }
        }
    }

    var runConstructor = function (base, name, obj, extendName) {
        var eClone, oClone, pClone, result;

        // Add to the extend list.
        obj.info.extendList.push (extendName);

        // Snapshot current state object.
        pClone = Object.assign ({}, obj.p);
        oClone = Object.assign ({}, obj.o);
        eClone = Object.assign ({}, obj.e);

        // Run the constructor.
        base (obj.o, obj.p, obj.d, obj.e, obj.o);

        // Throw error if object does not have a publicly
        // shared setup method.
        if (!obj.o.setup) { obj.o.setup = tm.emptyFunc; }

        if (obj.o.setup) {
            // obj.o.setup (obj.d._config);
            obj.setupList.push (obj.o.setup);
            delete obj.o.setup;
        }
        else {
            if (extendName !== name) {
                throw new Error ('Unable to extend <' + name + '> from the <' + extendName + '> object. The <' + extendName + '> object does not have a publicly shared "setup" method.');
            }
            else {
                throw new Error ('The <' + name + '> object does not have a publicly shared "setup" method.');
            }
        }

        // Confirm the object's original methods
        // have NOT been modified.
        ensureOriginalMethod (name, pClone, obj.p, 'private');
        ensureOriginalMethod (name, oClone, obj.o, 'shared');
        ensureOriginalMethod (name, eClone, obj.e, 'event');
        
        // Wrap each override method.
        wrapOverrideMethod (name, 'shared', obj.override.o, obj.o);
        wrapOverrideMethod (name, 'private', obj.override.p, obj.p);
        wrapOverrideMethod (name, 'event', obj.override.e, obj.e);
    }

    var ensureOriginalMethod = function (name, source, target, area) {
        var item, key, list;

        list = source;
        for (key in list) {
            if (source [key] !== target [key]) {
                throw new Error ('Incorrectly overriding the <' + name + '> object\'s pre-existing "' + key + '" method. To override this method use the ' + area + ' area\'s override () method.');
            }
        }
    }

    var extend = function (name, obj, extendList) {
        var base, clone, extendName;

        if (extendList) {
            extendList.forEach (function (extendName) {
                base = cache.object [extendName];
                if (base) {
                    // Grab the extension list and begin
                    // extending the object.
                    extend (name, obj, base._extendList);

                    // Run the extending object constructor.
                    runConstructor (base, name, obj, extendName);
                    
                    // TODO: Remove this code...?
                    if (obj.d.useChirp && !obj.e.override) {
                        obj.e.override = createOverrideMethod (obj, 'e');
                    }
                }
                else {
                    throw new Error ('Unable to extend <' + name + '>. The inheritance parent <' + extendName + '> does not exist.')
                }
            })
        }
    }

    var deReference = function (list) {
        // Clear out the references.
        var item, key;
        for (key in list) {
            list [key] = null;
            delete list [key];
        }
    }

    var wrapKill = function (obj) {
        return function () {
            // Create a seperate process to kill object.
            setTimeout (function () {
                // Clear out the references for data and methods.
                deReference (obj.d);
                deReference (obj.p);
                deReference (obj.o);
                deReference (obj.e);
            }, 10);
        }
    }

    var setup = function () {
        var tmConfig;

        // Load the preloaded loaders to load.
        if (preload.load [0]) {
            o.load (preload.load [0]);
        }

        // Add the preloaded objects for the object cache.
        preload.object.forEach (function (item) {
            cache.object [item.name] = item.object;
        })

        return o;
    }

    function getLogLine (offset) {
        var index, list, line;

        if (!offset) { offset = 0; }
        if (window.isNodeJs) {
            index = 4 + offset;
        }
        else {
            if (window.navigator.userAgent.indexOf ('Firefox') !== -1){
                index = 3 + offset; // FF
            } else {
                index = 4 + offset; // Chrome
            }
        }

        line = {
            file: 'n/a',
            number: -1,
        }
        try {
            throw new Error ('Getting line number.');
        }
        catch (err) {
            list = err.stack.split ('\n') [index];

            // if (offset == -1) {
                // console.log (err.stack.split ('\n'))
            // }

            if (list) {
                list = list.substring (list.lastIndexOf ('/') + 1, list.length - 1);
                list = list.split (':');
                line.file = list [0];
                line.number = list [1];
                line.column = list [2];
            }

            return line;
        }
    }

    function addLogging () {

        // Add logging
        function warn (msg) {
            var line, info;

            // line = tm.getLogLine ();
            // info = '[' + line.file + ':' + line.number + ':' + line.column + ']';
            info = tm.getLineInfo ();
            if (window.isNodeJs) {
                console.warn ('\x1b[1m\x1b[38;5;0m\x1b[48;5;178m' + ' Warning:' + '\x1b[0m ' + msg [0] + '  \x1b[38;5;22m\x1b[48;5;233m ' + info + ' \x1b[0m')
            }
            else {
                console.warn ('%c' + msg [0] + '%c' + info, '', 'margin-left: 25px; padding: 0 15px 0 15px;');
            }
        }

        function error (msg, err) {
            var line, info;

            // line = tm.getLogLine ();
            // info = '[' + line.file + ':' + line.number + ':' + line.column + ']';
            info = tm.getLineInfo ();
            if (window.isNodeJs) {
                console.error ('\x1b[1m\x1b[38;5;15m\x1b[48;5;1m' + ' ERROR:' + '\x1b[0m ' + msg + '  \x1b[38;5;22m\x1b[48;5;233m ' + info + ' \x1b[0m')
            }
            else {
                console.error ('%c' + msg + '%c' + info, '', 'margin-left: 25px; padding: 0 15px 0 15px;');
            }

            return err;
        }

        // function log () {
        function log (msg, config) {
            var argList, end, i, info, item, line, list, msg;

            argList = [].slice.call(arguments);
            list = argList;
            end = list.length;

            msg = '';
            info = '';
            for (i = 0; i < end; i++) {
                item = list [i];
                msg += item [0] + ' ';
            }
            msg = msg.trim ();

            // Log to the console.
            info = tm.getLineInfo ();
            // info = '[' + line.file + ':' + line.number + ':' + line.column + ']';
            if (window.isNodeJs) {
                if (msg.length) {
                    console.log (msg + '  \x1b[38;5;22m\x1b[48;5;0m ' + info + ' \x1b[0m');
                }
                else {
                    console.log ('');
                }
            }
            else {
                console.log ('%c' + msg + '%c' + info, '', 'background: #fff; color: #fff; margin-left: 25px; padding: 0 15px 0 15px;');
            }
        }

        if (window.isNodeJs) {
            global.log = log;
            global.error = error;
            global.warn = warn;
        }
        else {
            window.log = log;
            window.error = error;
            window.warn = warn;

            window.global = window;
            console.log ('%c' + 'NOTE: ' + '%c' + 'Output from any "log ()" function call should be drag selected with mouse to get the details of the log call.', 'background: #494949; color: #fff; padding: 3px 10px 3px 10px; border-radius: 3px;', 'margin-left: 10px; padding: 0 0 0 0;')
        }
    }

    setup ();
    addLogging ();
    return o;
});
